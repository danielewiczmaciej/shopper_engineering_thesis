\chapter{OPIS TECHNICZNY}
\label{chapter:opis_techniczny}


\section{Aplikacja wit.ai}
W ramach projektu została stworzona aplikacja w systemie \textit{wit.ai}. Wit.ai to platforma do tworzenia interfejsów interaktywnych, która pozwala na budowanie aplikacji, które rozumieją naturalny język. Wit.ai pozwala na tworzenie modeli językowych, które są w stanie rozpoznawać intencje użytkownika na podstawie zdefiniowanych przez programistę fraz. Aplikacja ta jest wykorzystywana w projekcie do rozpoznawania intencji użytkownika na podstawie zdefiniowanych przez programistę fraz.

\subsection{Intencje i encje}

W celu nauczenia modelu językowego aplikacji wit.ai, należy zdefiniować intencje (ang. \textit{intents}), które mają być rozpoznawane przez aplikację. Intencje to frazy, które użytkownik może napisać, a które mają być zrozumiane przez aplikację. Każda intencja może zawierać wiele przykładów fraz, które są z nią związane. Przykładowe intencje, które zostały zdefiniowane w aplikacji wit.ai to:
\begin{itemize}
    \item \textit{add\_product\_to\_cart} - intencja dodania produktu do koszyka,
    \item \textit{remove\_product\_from\_cart} - intencja usunięcia produktu z koszyka,
    \item \textit{check\_cart} - intencja sprawdzenia zawartości koszyka,
    \item \textit{check\_item\_prices} - intencja sprawdzenia cen produktów,
    \item \textit{check\_item\_price\_in\_store} - intencja sprawdzenia ceny produktu w sklepie
\end{itemize}

Poza intencjami, w aplikacji wit.ai definiuje się również encje (ang. \textit{entities}). Encje to frazy, które mają być rozpoznawane przez aplikację jako konkretne wartości. Encje pomagają również w wykryciu intencji użytkownika. Przykładowe encje, które zostały zdefiniowane w aplikacji wit.ai to:
\begin{itemize}
    \item \textit{product} - encja reprezentująca nazwę produktu,
    \item \textit{store} - encja reprezentująca nazwę sklepu,
    \item \textit{view} - encja reprezentująca widok w aplikacji,
    \item \textit{category} - encja reprezentująca nazwę kategorii produktów
\end{itemize}

Po zdefiniowaniu intencji i encji, aplikacja wit.ai pozwala na trenowanie modelu językowego. Trenowanie modelu polega na przesłaniu do aplikacji wit.ai przykładów fraz, które mają być rozpoznawane przez aplikację. Po przesłaniu przykładów, aplikacja wit.ai trenuje model językowy. Po wstępnym treningu, aplikacja stara się sama sugerować intencje w procesie trenowania modelu. Pozwala to na sprawdzanie w czasie rzeczywistym, czy model językowy poprawnie rozpoznaje encje i intencje. Przykładowe frazy wykorzystane w procesie trenowania modelu to:
\begin{itemize}
    \item \textit{Where to buy apples}
    \item \textit{Remove cheese from cart},
    \item \textit{My app is stuck on loading},
    \item \textit{Is there dairy in castorama?}
\end{itemize}

\subsection{Kreator}

Wytrenowany model należy zaprogramować. W tym celu wit.ai udostępnia kreator (ang. \textit{composer}), który pozwala na zdefiniowanie akcji, które mają być wykonywane po rozpoznaniu intencji przez aplikację. Przykładowe akcje, które zostały zdefiniowane w aplikacji wit.ai przedstawiono na rysunku \ref{fig:wit_ai_composer}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/witai_composer.png}
    \caption{Kreator aplikacji wit.ai}
    \label{fig:wit_ai_composer}
\end{figure}

\subsubsection{Akcje}

W ramach kreatora dostępne są 4 moduły blokowe definiujące akcje. Są to:
\begin{itemize}
    \item \textit{Decision} - moduł decydujący o dalszym przebiegu akcji,
    \item \textit{Context} - moduł przechowujący kontekst akcji,
    \item \textit{Input} - moduł pobierający dane wejściowe,
    \item \textit{Response} - moduł generujący odpowiedź.
\end{itemize}

\subsubsection{Decision}

Moduł \textit{Decision} pozwala na zdefiniowanie warunków, które muszą być spełnione, aby akcja mogła zostać wykonana. Dostępne są poniższe warunki:
\begin{itemize}
    \item \textit{Intent} - sprawdza, czy intencja użytkownika jest zgodna z zdefiniowaną intencją,
    \item \textit{Entity} - sprawdza, czy encja użytkownika jest zgodna z zdefiniowaną encją,
    \item \textit{Context} - sprawdza, czy kontekst akcji jest zgodny z zdefiniowanym kontekstem,
    \item \textit{Trait} - sprawdza, czy cecha akcji jest zgodna z zdefiniowaną cechą.
    \item \textit{Not/And/Or} - służy do łączenia warunków.
\end{itemize}

\subsubsection{Context}
Moduł \textit{Context} pozwala na zdefiniowanie kontekstu akcji. Kontekst to zmienna, która przechowuje informacje o stanie akcji. Kontekst może być wykorzystywany w kolejnych akcjach. W ramach tego modułu możn a wykonać 4 akcje:
\begin{itemize}
    \item \textit{Set} - ustawia wartość kontekstu,
    \item \textit{Save} - zapisuje rozpoznaną encję do kontekstu,
    \item \textit{Copy} - kopiuje wskazaną wartość kontekstu,
    \item \textit{Clear} - czyści kontekst.
\end{itemize}

\subsubsection{Input}
Moduł \textit{Input} pozwala na pobranie danych wejściowych. Jest on wykorzystywany na początku kreatora, w celu przyjęcia wiadomości od użytkownika. Można go również użyć do uzyskania dodatkowych informacji od użytkownika.

\subsubsection{Response}
Moduł \textit{Response} pozwala na zdefiniowanie odpowiedzi, która ma zostać zwrócona do użytkownika. W odpowiedzi można wykorzystać zmienne zdefiniowane w kontekście akcji. Można zwrócić tekst, obraz, dźwięk, link, czy dowolny inny format. Oprócz tego, można również zwrócić nazwę funkcji, która ma zostać wykonana po zakończeniu akcji.


\subsection{Testowanie i publikacja}
Po zdefiniowaniu akcji, aplikacja wit.ai pozwala na przetestowanie modelu językowego. W tym celu można wpisać dowolną frazę, a aplikacja zwróci intencję oraz encje, które rozpoznała. Po zakończeniu testowania, model językowy można opublikować. Po opublikowaniu modelu, aplikacja wit.ai generuje token, który pozwala na integrację modelu z dowolną aplikacją. Token ten jest wykorzystywany w aplikacji mobilnej, aby komunikować się z modelem językowym.


\section{Serwer}

\subsection{Struktura serwera}
Na serwerze zaimplementowano kilka modułów, które są odpowiedzialne za przetwarzanie żądań użytkownika. Każdy moduł odpowiada za obsługę jednego zasobu, takiego jak użytkownik, produkt, czy koszyk. Każdy moduł składa się z trzech plików:
\begin{itemize}
    \item \textit{router} - plik zawierający definicję ścieżek API,
    \item \textit{controller} - plik zawierający logikę przetwarzania żądań,
    \item \textit{service} - plik zawierający logikę dostępu do bazy danych.
\end{itemize}

Oprócz modułów, na serwerze zaimplementowano również oprogramowanie pośredniczące (ang. \textit{middleware}), które jest odpowiedzialne za przetwarzanie żądań przed przekazaniem ich do modułów. Middleware w tym przypadku jest wykorzystywane do autoryzacji użytkownika.
Poza wyżej wymienionymi, serwer zawiera równięz kod potrzebny do migracji lub ponownego postawienia bazy danych.

\subsubsection{Router}
Router jest odpowiedzialny za definiowanie ścieżek API. Każda ścieżka API odpowiada jednej akcji, która ma zostać wykonana. Router przekazuje żądanie do kontrolera, który jest odpowiedzialny za przetworzenie żądania. Przykładowa definicja ścieżki API w pliku router przedstawiona jest na listingu \ref{lst:router}.

\begin{figure}[H]
\begin{lstlisting}[language=JavaScript, caption=Przykładowa definicja ścieżki API, label=lst:router]
import { Router } from 'express';
import { userController } from './user.controller.js';
import { authMiddleware } from '../../middleware/auth.middleware.js';

export const userRouter = Router();

// Apply authMiddleware to all user routes
userRouter.use(authMiddleware);

// Protected user routes
userRouter.get('/', userController.getAll);
userRouter.get('/:id', userController.getById);
userRouter.post('/', userController.create);
userRouter.put('/:id', userController.update);
userRouter.delete('/:id', userController.delete);
\end{lstlisting}
\end{figure}

\subsubsection{Controller}
Controller jest odpowiedzialny za przetwarzanie żądań. Każda metoda kontrolera odpowiada jednej akcji, która ma zostać wykonana. Kontroler przekazuje żądanie do serwisu, który jest odpowiedzialny za dostęp do bazy danych. Przykładowa definicja kontrolera przedstawiona jest na listingu \ref{lst:controller}.


\begin{figure}[H]
\begin{lstlisting}[language=JavaScript, caption=Przykładowa definicja kontrolera, label=lst:controller]
import { userService } from './user.service.js';

export const userController = {
    getAll: async (req, res, next) => {
    try {
        const users = await userService.getAll();

        res.json(users);
    } catch (error) {
        next(error);
    }
    },
    getById: async (req, res, next) => {
    try {
        const id = req.params.id;

        const user = await userService.getById(id);

        res.json(user);
    } catch (error) {
        next(error);
    }
    },
    create: async (req, res, next) => {
    try {
        const message = await userService.create(req.body);

        res.json(message);
    } catch (error) {
        next(error);
    }
    },
    update: async (req, res, next) => {
    try {
        const id = req.params.id;

        const message = await userService.update(req.body, id);

        res.json(message);
    } catch (error) {
        next(error);
    }
    },
    delete: async (req, res, next) => {
    try {
        const id = req.params.id;

        const message = await userService.delete(id);

        res.json(message);
    } catch (error) {
        next(error);
    }
    },
};        
\end{lstlisting}
\end{figure}
\subsubsection{Service}
Service jest odpowiedzialny za dostęp do bazy danych. Każda metoda serwisu odpowiada jednej akcji, która ma zostać wykonana. Serwis przekazuje żądanie do bazy danych, a następnie zwraca wynik do kontrolera. Przykładowa definicja funkcji serwisu przedstawiona jest na listingu \ref{lst:service}.

\begin{figure}[H]
\begin{lstlisting}[language=JavaScript, caption=Przykładowa definicja serwisu, label=lst:service]
    create: async (newUser) => {
        const user = await client.query(
          "INSERT INTO users (email, password, first_name, last_name) VALUES ("${newUser.email}", "${newUser.password}", "${newUser.name}", "${newUser.last_name}") returning *;"
        );
    
        if (!user.rows.length) {
          throw new ErrorWithStatus("Couldn't create new user with given data:\n${newUser}", 400);
        }
    
        return {
          message: 'User has been successfully created.',
        };
      },
    
\end{lstlisting}
\end{figure}

\section{CRUD}
CRUD to skrót od angielskich słów Create, Read, Update, Delete. Jest to zestaw podstawowych operacji, które można wykonać na bazie danych. Operacje te mają na celu zapewnienie spójności danych w przestrzeni bazy danych i serwera. W ramach projektu zaimplementowano operacje CRUD dla wszystkich encji występujących w systemie. Każda encja posiada swoje metody CRUD, które są odpowiedzialne za dodawanie, odczytywanie, aktualizowanie i usuwanie danych z bazy danych. 
% \begin{samepage}
% \tiny
% \dirtree{%
% .1 Shopper/.
% .2 node\_modules/.
% .2 src/.
% .3 api/.
% .4 auth/.
% .5 auth.router.js.
% .4 cartItems/.
% .5 cartItems.controller.js.
% .5 cartItems.router.js.
% .5 cartItems.service.js.
% .4 carts/.
% .5 cart.controller.js.
% .5 cart.router.js.
% .5 cart.service.js.
% .4 categories/.
% .5 category.controller.js.
% .5 category.router.js.
% .5 category.service.js.
% .4 products/.
% .5 product.controller.js.
% .5 product.router.js.
% .5 product.service.js.
% .4 sections/.
% .5 section.controller.js.
% .5 section.router.js.
% .5 section.service.js.
% .4 stores/.
% .5 store.controller.js.
% .5 store.router.js.
% .5 store.service.js.
% .4 units/.
% .5 unit.controller.js.
% .5 unit.router.js.
% .5 unit.service.js.
% .4 users/.
% .5 user.controller.js.
% .5 user.router.js.
% .5 user.service.js.
% .3 db/.
% .4 migrations/.
% .4 seeds/.
% .4 connect.js.
% .3 error/.
% .4 error-handler.js.
% .4 error-with-status.js.
% .3 middleware/.
% .4 auth.middleware.js.
% .3 ecosystem.config.cjs.
% .3 server.js.
% .2 .env.
% .2 .gitignore.
% .2 package\_lock.json
% .2 package.json.
% .2 README.md.
% }
% \end{samepage}